
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mongo-kit-go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/edaniel30/mongo-kit-go/client.go (0.0%)</option>
				
				<option value="file1">github.com/edaniel30/mongo-kit-go/config.go (100.0%)</option>
				
				<option value="file2">github.com/edaniel30/mongo-kit-go/context.go (100.0%)</option>
				
				<option value="file3">github.com/edaniel30/mongo-kit-go/errors.go (100.0%)</option>
				
				<option value="file4">github.com/edaniel30/mongo-kit-go/operations.go (0.0%)</option>
				
				<option value="file5">github.com/edaniel30/mongo-kit-go/query.go (98.4%)</option>
				
				<option value="file6">github.com/edaniel30/mongo-kit-go/repository.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package mongo_kit provides a MongoDB client wrapper with convenient methods
// for connection management and database operations.
package mongo_kit

import (
        "context"
        "fmt"
        "sync"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// Client wraps the MongoDB driver client with convenience methods.
// It provides a simpler API for common operations while maintaining thread-safety.
// The client is safe for concurrent use across multiple goroutines.
type Client struct {
        config    Config
        client    *mongo.Client
        defaultDB *mongo.Database
        mu        sync.RWMutex
        closed    bool
}

// New creates a new MongoDB client with the given configuration.
// Configuration uses the functional options pattern for flexibility.
//
// The client will automatically:
//   - Validate the configuration
//   - Connect to MongoDB
//   - Verify the connection with a ping
//
// Example:
//
//        client, err := mongo_kit.New(
//            mongo_kit.DefaultConfig(),
//            mongo_kit.WithURI("mongodb://localhost:27017"),
//            mongo_kit.WithDatabase("myapp"),
//            mongo_kit.WithMaxPoolSize(200),
//        )
//        if err != nil {
//            log.Fatal(err)
//        }
//        defer client.Close(context.Background())
//
// Returns an error if:
//   - Configuration is invalid
//   - Connection to MongoDB fails
//   - Ping verification fails
func New(cfg Config, opts ...Option) (*Client, error) <span class="cov0" title="0">{
        if err := cfg.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;cfg)
        }</span>

        <span class="cov0" title="0">var clientOpts *options.ClientOptions
        // If user provided custom ClientOptions, use them as base
        if cfg.ClientOptions != nil </span><span class="cov0" title="0">{
                clientOpts = cfg.ClientOptions
        }</span> else<span class="cov0" title="0"> {
                clientOpts = options.Client()
        }</span>

        <span class="cov0" title="0">clientOpts.ApplyURI(cfg.URI)
        clientOpts.SetMaxPoolSize(cfg.MaxPoolSize)
        clientOpts.SetRetryWrites(true)
        clientOpts.SetRetryReads(true)

        ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout)
        defer cancel()

        mongoClient, err := mongo.Connect(ctx, clientOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newConnectionError(err)
        }</span>

        <span class="cov0" title="0">ctx, cancel = context.WithTimeout(context.Background(), cfg.Timeout)
        defer cancel()

        if err := mongoClient.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                if disconnectErr := mongoClient.Disconnect(context.Background()); disconnectErr != nil </span><span class="cov0" title="0">{
                        return nil, newConnectionError(fmt.Errorf("ping failed: %w, disconnect also failed: %v", err, disconnectErr))
                }</span>
                <span class="cov0" title="0">return nil, newConnectionError(err)</span>
        }

        <span class="cov0" title="0">return &amp;Client{
                config:    cfg,
                client:    mongoClient,
                defaultDB: mongoClient.Database(cfg.Database),
                closed:    false,
        }, nil</span>
}

// Ping verifies the connection to MongoDB.
// Returns an error if the client is closed or the connection check fails.
//
// Example:
//
//        if err := client.Ping(ctx); err != nil {
//            log.Println("Connection lost:", err)
//        }
func (c *Client) Ping(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.closed </span><span class="cov0" title="0">{
                return ErrClientClosed
        }</span>

        <span class="cov0" title="0">return c.client.Ping(ctx, nil)</span>
}

// IsConnected checks if the client is connected to MongoDB.
// This is a convenience method that calls Ping and returns true if successful.
//
// Example:
//
//        if !client.IsConnected(ctx) {
//            log.Println("Not connected to MongoDB")
//        }
func (c *Client) IsConnected(ctx context.Context) bool <span class="cov0" title="0">{
        return c.Ping(ctx) == nil
}</span>

// Close closes the MongoDB client connection gracefully.
// After calling Close, the client should not be used.
// Calling Close multiple times is safe and will only disconnect once.
//
// Example:
//
//        defer client.Close(context.Background())
func (c *Client) Close(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">c.closed = true
        return c.client.Disconnect(ctx)</span>
}

// IsClosed returns true if the client has been closed.
//
// Example:
//
//        if client.IsClosed() {
//            log.Println("Client is closed")
//        }
func (c *Client) IsClosed() bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.closed
}</span>

// StartSession starts a new session for transaction support.
// Returns an error if the client is closed.
//
// Example:
//
//        session, err := client.StartSession()
//        if err != nil {
//            log.Fatal(err)
//        }
//        defer session.EndSession(context.Background())
func (c *Client) StartSession(opts ...*options.SessionOptions) (mongo.Session, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.closed </span><span class="cov0" title="0">{
                return nil, ErrClientClosed
        }</span>

        <span class="cov0" title="0">return c.client.StartSession(opts...)</span>
}

// UseSession executes a function within a session.
// This is useful for running operations that need to be part of the same session.
//
// Example:
//
//        err := client.UseSession(ctx, func(sessCtx mongo.SessionContext) error {
//            // Your operations here
//            return nil
//        })
func (c *Client) UseSession(ctx context.Context, fn func(mongo.SessionContext) error) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if c.closed </span><span class="cov0" title="0">{
                return ErrClientClosed
        }</span>

        <span class="cov0" title="0">return c.client.UseSession(ctx, fn)</span>
}

// GetDatabase returns a handle to the specified database.
// If name is empty, returns the default database from config (cached, no lock needed).
//
// Example:
//
//        db := client.GetDatabase("myapp")
//        db := client.GetDatabase("") // uses default from config
func (c *Client) GetDatabase(name string) *mongo.Database <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return c.defaultDB
        }</span>

        <span class="cov0" title="0">c.mu.RLock()
        defer c.mu.RUnlock()

        return c.client.Database(name)</span>
}

// GetCollection returns a handle to the specified collection in the default database.
// This method does not acquire locks and is safe to call from within locked contexts.
//
// Example:
//
//        coll := client.GetCollection("users")
func (c *Client) GetCollection(collectionName string) *mongo.Collection <span class="cov0" title="0">{
        return c.defaultDB.Collection(collectionName)
}</span>

// GetCollectionFrom returns a handle to the specified collection in the specified database.
//
// Example:
//
//        coll := client.GetCollectionFrom("analytics", "events")
func (c *Client) GetCollectionFrom(databaseName, collectionName string) *mongo.Collection <span class="cov0" title="0">{
        return c.GetDatabase(databaseName).Collection(collectionName)
}</span>

// GetConfig returns a copy of the client configuration.
//
// Example:
//
//        cfg := client.GetConfig()
//        fmt.Println("Connected to:", cfg.URI)
func (c *Client) GetConfig() Config <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.config
}</span>

// checkState verifies that the client is not closed.
// IMPORTANT: This method does NOT acquire any locks. The caller MUST hold c.mu.RLock()
// before calling this method.
// Returns ErrClientClosed if the client has been closed.
func (c *Client) checkState() error <span class="cov0" title="0">{
        if c.closed </span><span class="cov0" title="0">{
                return ErrClientClosed
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package mongo_kit

import (
        "time"

        "go.mongodb.org/mongo-driver/mongo/options"
)

// Config holds the MongoDB client configuration.
// Use DefaultConfig() to get sensible defaults, then customize with Option functions.
type Config struct {
        URI      string // MongoDB connection URI (required)
        Database string // Default database name (required)

        MaxPoolSize   uint64                 // Maximum number of connections in the connection pool (default: 100)
        Timeout       time.Duration          // Default timeout for all operations (default: 10s)
        ClientOptions *options.ClientOptions // Direct access to MongoDB driver options for advanced use cases
}

// DefaultConfig returns a Config with sensible default values.
// This is the recommended starting point for most applications.
//
// Default values:
//   - URI: "mongodb://localhost:27017"
//   - Database: "default"
//   - MaxPoolSize: 100
//   - Timeout: 10 seconds
//
// Example:
//
//        cfg := mongo_kit.DefaultConfig()
//        client, err := mongo_kit.New(cfg, mongo_kit.WithURI("mongodb://prod:27017"))
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                URI:         "mongodb://localhost:27017",
                Database:    "default",
                MaxPoolSize: 100,
                Timeout:     10 * time.Second,
        }
}</span>

// Option is a function that modifies a Config.
// Use Option functions with New() to customize the configuration.
type Option func(*Config)

// WithURI sets the MongoDB connection URI.
//
// Example:
//
//        mongo_kit.WithURI("mongodb://user:pass@localhost:27017")
//        mongo_kit.WithURI("mongodb+srv://cluster.mongodb.net")
func WithURI(uri string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.URI = uri
        }</span>
}

// WithDatabase sets the default database name.
// All operations without an explicit database will use this database.
//
// Example:
//
//        mongo_kit.WithDatabase("myapp")
func WithDatabase(database string) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Database = database
        }</span>
}

// WithMaxPoolSize sets the maximum number of connections in the connection pool.
// Default is 100. Increase for high-concurrency applications.
//
// Example:
//
//        mongo_kit.WithMaxPoolSize(200)
func WithMaxPoolSize(size uint64) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.MaxPoolSize = size
        }</span>
}

// WithTimeout sets the default timeout for all database operations.
// This timeout applies to operations that don't specify their own context timeout.
// Default is 10 seconds.
//
// Example:
//
//        mongo_kit.WithTimeout(30 * time.Second)
func WithTimeout(timeout time.Duration) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.Timeout = timeout
        }</span>
}

// WithClientOptions allows you to directly configure the underlying MongoDB driver options.
// This is an escape hatch for advanced configurations not covered by the basic options.
//
// Use this when you need fine-grained control over:
//   - Minimum pool size
//   - Retry behavior
//   - TLS/SSL settings
//   - Compression
//   - Read preferences
//   - Write concerns
//   - And more...
//
// Example:
//
//        clientOpts := options.Client()
//        clientOpts.SetMinPoolSize(10)
//        clientOpts.SetRetryWrites(true)
//        clientOpts.SetReadPreference(readpref.Secondary())
//        mongo_kit.WithClientOptions(clientOpts)
//
// Note: Settings applied via WithClientOptions will override basic options like MaxPoolSize.
func WithClientOptions(opts *options.ClientOptions) Option <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.ClientOptions = opts
        }</span>
}

// Validate checks if the configuration is valid.
// Returns a ConfigError if any required field is missing or invalid.
func (c *Config) validate() error <span class="cov8" title="1">{
        if c.URI == "" </span><span class="cov8" title="1">{
                return newConfigFieldError("URI", "is required")
        }</span>

        <span class="cov8" title="1">if c.Database == "" </span><span class="cov8" title="1">{
                return newConfigFieldError("Database", "is required")
        }</span>

        <span class="cov8" title="1">if c.MaxPoolSize == 0 </span><span class="cov8" title="1">{
                return newConfigFieldError("MaxPoolSize", "must be greater than 0")
        }</span>

        <span class="cov8" title="1">if c.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                return newConfigFieldError("Timeout", "must be greater than 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mongo_kit

import (
        "context"
)

// Context Helpers
//
// This file provides context helper methods to simplify timeout management
// for database operations.
//
// See docs/context.md for detailed usage guide and examples.

// NewContext creates a new context with the default timeout from config.
//
// Use this for standalone operations (CLI tools, scripts, background jobs).
// DO NOT use in web handlers - use the request context instead.
//
// Returns a context with timeout and a cancel function (always call defer cancel()).
func (c *Client) NewContext() (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        c.mu.RLock()
        timeout := c.config.Timeout
        c.mu.RUnlock()

        return context.WithTimeout(context.Background(), timeout)
}</span>

// WithTimeout creates a child context with timeout from an existing parent context.
//
// Use this when you have a parent context (from HTTP request, gRPC) but want to add
// a specific timeout for database operations.
//
// The resulting context will be canceled when the DB timeout expires, the parent is
// canceled, or the returned cancel function is called.
//
// Preserves all values from the parent context (trace IDs, user info, etc.).
func (c *Client) WithTimeout(parent context.Context) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        c.mu.RLock()
        timeout := c.config.Timeout
        c.mu.RUnlock()

        return context.WithTimeout(parent, timeout)
}</span>

// EnsureTimeout ensures the context has a deadline.
//
// If the context already has a deadline, returns it unchanged.
// If the context has no deadline, adds the default timeout from config.
//
// Use this when you're unsure if the context has a deadline or writing
// library/reusable code that accepts contexts from callers.
func (c *Client) EnsureTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        // Check if context already has a deadline
        if _, hasDeadline := ctx.Deadline(); hasDeadline </span><span class="cov8" title="1">{
                // Context has deadline, return it unchanged with no-op cancel
                return ctx, func() </span>{<span class="cov8" title="1">}</span>
        }

        // No deadline exists, add default timeout from config
        <span class="cov8" title="1">c.mu.RLock()
        timeout := c.config.Timeout
        c.mu.RUnlock()

        return context.WithTimeout(ctx, timeout)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package mongo_kit

import (
        "errors"
        "fmt"
)

// Public Error Types
// These types are exported so users can use errors.As() to inspect them
// and access their fields for better error handling.

// ConfigError represents a configuration validation error.
// Users can access the Field and Message to understand what configuration is invalid.
type ConfigError struct {
        Field   string // The configuration field that caused the error (optional)
        Message string // Human-readable error message
}

func (e *ConfigError) Error() string <span class="cov8" title="1">{
        if e.Field != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("mongo: config error [%s]: %s", e.Field, e.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("mongo: config error: %s", e.Message)</span>
}

// ConnectionError represents a connection failure to MongoDB.
// The Cause field contains the underlying error from the MongoDB driver.
type ConnectionError struct {
        Cause error // The underlying error that caused the connection failure
}

func (e *ConnectionError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("mongo: connection failed: %v", e.Cause)
}</span>

func (e *ConnectionError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// OperationError represents an error that occurred during a database operation.
// The Op field identifies which operation failed, and Cause contains the underlying error.
type OperationError struct {
        Op    string // The name of the operation that failed (e.g., "find", "insert", "update")
        Cause error  // The underlying error from MongoDB driver
}

func (e *OperationError) Error() string <span class="cov8" title="1">{
        if e.Cause != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("mongo: operation '%s' failed: %v", e.Op, e.Cause)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("mongo: operation '%s' failed", e.Op)</span>
}

func (e *OperationError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// Sentinel Errors
// These are sentinel errors that can be checked using errors.Is().

var (
        // ErrClientClosed is returned when an operation is attempted on a closed client.
        // Use errors.Is(err, mongo.ErrClientClosed) to check for this error.
        ErrClientClosed = errors.New("mongo: client is closed")
)

// Internal constructor functions

// newConfigFieldError creates a configuration error with a specific field.
func newConfigFieldError(field, message string) error <span class="cov8" title="1">{
        return &amp;ConfigError{Field: field, Message: message}
}</span>

// newConnectionError creates a connection error wrapping an underlying cause.
func newConnectionError(cause error) error <span class="cov8" title="1">{
        return &amp;ConnectionError{Cause: cause}
}</span>

// newOperationError creates an operation error for a specific operation and cause.
func newOperationError(operation string, cause error) error <span class="cov8" title="1">{
        return &amp;OperationError{Op: operation, Cause: cause}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package mongo_kit

import (
        "context"
        "errors"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// Database Operations
//
// This file provides all database operations (CRUD, aggregations, indexes, etc.).
//
// See docs/operations.md for detailed usage guide and examples.

// InsertOne inserts a single document into the specified collection.
// Returns *mongo.InsertOneResult with the InsertedID field.
func (c *Client) InsertOne(ctx context.Context, collection string, document any) (*mongo.InsertOneResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.InsertOne(ctx, document)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("insert one", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// InsertMany inserts multiple documents into the specified collection in a single operation.
// Returns *mongo.InsertManyResult with the InsertedIDs map.
func (c *Client) InsertMany(ctx context.Context, collection string, documents []any) (*mongo.InsertManyResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.InsertMany(ctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("insert many", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// FindOne finds a single document matching the filter and decodes it into result.
// Returns mongo.ErrNoDocuments if no document matches.
func (c *Client) FindOne(ctx context.Context, collection string, filter any, result any, opts ...*options.FindOneOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        err := coll.FindOne(ctx, filter, opts...).Decode(result)
        if err != nil </span><span class="cov0" title="0">{
                // Return ErrNoDocuments directly for clearer error handling
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return newOperationError("find one", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Find finds all documents matching the filter and decodes them into results.
// Empty results is not an error.
func (c *Client) Find(ctx context.Context, collection string, filter any, results any, opts ...*options.FindOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        cursor, err := coll.Find(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return newOperationError("find", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        if err := cursor.All(ctx, results); err != nil </span><span class="cov0" title="0">{
                return newOperationError("find decode", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateOne updates a single document matching the filter.
// Update must use operators like $set, $inc, etc.
func (c *Client) UpdateOne(ctx context.Context, collection string, filter any, update any, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.UpdateOne(ctx, filter, update, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("update one", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// UpdateMany updates all documents matching the filter.
// Update must use operators like $set, $inc, etc.
func (c *Client) UpdateMany(ctx context.Context, collection string, filter any, update any, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.UpdateMany(ctx, filter, update, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("update many", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ReplaceOne replaces a single document matching the filter with a new document.
// Replaces the entire document (except _id). Cannot use update operators.
func (c *Client) ReplaceOne(ctx context.Context, collection string, filter any, replacement any, opts ...*options.ReplaceOptions) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.ReplaceOne(ctx, filter, replacement, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("replace one", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// DeleteOne deletes a single document matching the filter.
// Returns *mongo.DeleteResult with DeletedCount (0 or 1).
func (c *Client) DeleteOne(ctx context.Context, collection string, filter any, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.DeleteOne(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("delete one", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// DeleteMany deletes all documents matching the filter.
// Use bson.M{} to delete all documents.
func (c *Client) DeleteMany(ctx context.Context, collection string, filter any, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.DeleteMany(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("delete many", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// CountDocuments counts the number of documents matching the filter.
// Accurate but slower than EstimatedDocumentCount.
func (c *Client) CountDocuments(ctx context.Context, collection string, filter any, opts ...*options.CountOptions) (int64, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        count, err := coll.CountDocuments(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, newOperationError("count documents", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// Aggregate runs an aggregation pipeline and decodes results.
// Pipeline must be []bson.M, []bson.D, mongo.Pipeline, or bson.A.
func (c *Client) Aggregate(ctx context.Context, collection string, pipeline any, results any, opts ...*options.AggregateOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate pipeline type
        <span class="cov0" title="0">switch pipeline.(type) </span>{
        case []bson.M, []bson.D, mongo.Pipeline, bson.A:<span class="cov0" title="0"></span>
                // Valid types - continue
        case nil:<span class="cov0" title="0">
                return newOperationError("aggregate", errors.New("pipeline cannot be nil"))</span>
        default:<span class="cov0" title="0">
                return newOperationError("aggregate", errors.New("pipeline must be []bson.M, []bson.D, mongo.Pipeline, or bson.A"))</span>
        }

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        cursor, err := coll.Aggregate(ctx, pipeline, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return newOperationError("aggregate", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        if err := cursor.All(ctx, results); err != nil </span><span class="cov0" title="0">{
                return newOperationError("aggregate decode", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindOneAndUpdate finds, updates, and returns the document atomically.
// Use options.After to return the updated document.
func (c *Client) FindOneAndUpdate(ctx context.Context, collection string, filter any, update any, result any, opts ...*options.FindOneAndUpdateOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        err := coll.FindOneAndUpdate(ctx, filter, update, opts...).Decode(result)
        if err != nil </span><span class="cov0" title="0">{
                // Return ErrNoDocuments directly for clearer error handling
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return newOperationError("find one and update", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// FindOneAndReplace finds, replaces, and returns the document atomically.
// Use options.After to return the replaced document.
func (c *Client) FindOneAndReplace(ctx context.Context, collection string, filter any, replacement any, result any, opts ...*options.FindOneAndReplaceOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        err := coll.FindOneAndReplace(ctx, filter, replacement, opts...).Decode(result)
        if err != nil </span><span class="cov0" title="0">{
                // Return ErrNoDocuments directly for clearer error handling
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return newOperationError("find one and replace", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// FindOneAndDelete finds, deletes, and returns the deleted document atomically.
// Returns mongo.ErrNoDocuments if no document matches.
func (c *Client) FindOneAndDelete(ctx context.Context, collection string, filter any, result any, opts ...*options.FindOneAndDeleteOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        err := coll.FindOneAndDelete(ctx, filter, opts...).Decode(result)
        if err != nil </span><span class="cov0" title="0">{
                // Return ErrNoDocuments directly for clearer error handling
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return newOperationError("find one and delete", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// BulkWrite executes multiple write operations in a single batch.
// More efficient than individual operations for bulk changes.
func (c *Client) BulkWrite(ctx context.Context, collection string, models []mongo.WriteModel, opts ...*options.BulkWriteOptions) (*mongo.BulkWriteResult, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        result, err := coll.BulkWrite(ctx, models, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("bulk write", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Distinct returns all unique values for a specified field.
// Use bson.M{} filter for all documents.
func (c *Client) Distinct(ctx context.Context, collection string, fieldName string, filter any, opts ...*options.DistinctOptions) ([]any, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        results, err := coll.Distinct(ctx, fieldName, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("distinct", err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// CreateIndex creates a new index on the specified collection.
// Returns the name of the created index.
func (c *Client) CreateIndex(ctx context.Context, collection string, keys any, opts ...*options.IndexOptions) (string, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        indexModel := mongo.IndexModel{Keys: keys}

        if len(opts) &gt; 0 </span><span class="cov0" title="0">{
                indexModel.Options = opts[0]
        }</span>

        <span class="cov0" title="0">indexName, err := coll.Indexes().CreateOne(ctx, indexModel)
        if err != nil </span><span class="cov0" title="0">{
                return "", newOperationError("create index", err)
        }</span>

        <span class="cov0" title="0">return indexName, nil</span>
}

// CreateIndexes creates multiple indexes across different collections.
// Returns map of collection names to created index names.
func (c *Client) CreateIndexes(ctx context.Context, indexes map[string][]mongo.IndexModel) (map[string][]string, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make(map[string][]string)

        for collectionName, models := range indexes </span><span class="cov0" title="0">{
                if len(models) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">coll := c.GetCollection(collectionName)
                indexNames, err := coll.Indexes().CreateMany(ctx, models)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, newOperationError("create indexes on "+collectionName, err)
                }</span>

                <span class="cov0" title="0">result[collectionName] = indexNames</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// DropIndex removes an index from the specified collection.
// Returns error if index doesn't exist.
func (c *Client) DropIndex(ctx context.Context, collection string, indexName string) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        _, err := coll.Indexes().DropOne(ctx, indexName)
        if err != nil </span><span class="cov0" title="0">{
                return newOperationError("drop index", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListIndexes retrieves information about all indexes on the collection.
// Returns slice of index specifications including name, keys, and options.
func (c *Client) ListIndexes(ctx context.Context, collection string) ([]bson.M, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        cursor, err := coll.Indexes().List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("list indexes", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var indexes []bson.M
        if err := cursor.All(ctx, &amp;indexes); err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("list indexes decode", err)
        }</span>

        <span class="cov0" title="0">return indexes, nil</span>
}

// ListCollections retrieves the names of all collections in the default database.
// Returns slice of collection names.
func (c *Client) ListCollections(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">db := c.client.Database(c.config.Database)
        cursor, err := db.ListCollectionNames(ctx, bson.D{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("list collections", err)
        }</span>

        <span class="cov0" title="0">return cursor, nil</span>
}

// CreateCollection explicitly creates a new collection in the default database.
// Use options for validation, capped collections, or time series.
func (c *Client) CreateCollection(ctx context.Context, collection string, opts ...*options.CreateCollectionOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">db := c.client.Database(c.config.Database)
        err := db.CreateCollection(ctx, collection, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return newOperationError("create collection", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateCollections creates multiple collections in the default database.
// Map keys are collection names, values are optional CreateCollectionOptions.
func (c *Client) CreateCollections(ctx context.Context, collections map[string]*options.CreateCollectionOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">db := c.client.Database(c.config.Database)

        for collectionName, opts := range collections </span><span class="cov0" title="0">{
                // CreateCollection accepts variadic options, so we can pass nil or the options directly
                var createOpts []*options.CreateCollectionOptions
                if opts != nil </span><span class="cov0" title="0">{
                        createOpts = []*options.CreateCollectionOptions{opts}
                }</span>

                <span class="cov0" title="0">if err := db.CreateCollection(ctx, collectionName, createOpts...); err != nil </span><span class="cov0" title="0">{
                        return newOperationError("create collection "+collectionName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// FindByID finds a single document by its _id field.
// ID can be string or primitive.ObjectID.
func (c *Client) FindByID(ctx context.Context, collection string, id any, result any) error <span class="cov0" title="0">{
        var objID primitive.ObjectID
        var err error

        switch v := id.(type) </span>{
        case string:<span class="cov0" title="0">
                objID, err = primitive.ObjectIDFromHex(v)
                if err != nil </span><span class="cov0" title="0">{
                        return newOperationError("find by id", err)
                }</span>
        case primitive.ObjectID:<span class="cov0" title="0">
                if v.IsZero() </span><span class="cov0" title="0">{
                        return newOperationError("find by id", errors.New("ObjectID cannot be zero"))
                }</span>
                <span class="cov0" title="0">objID = v</span>
        default:<span class="cov0" title="0">
                return newOperationError("find by id", mongo.ErrInvalidIndexValue)</span>
        }

        <span class="cov0" title="0">filter := bson.M{"_id": objID}
        return c.FindOne(ctx, collection, filter, result)</span>
}

// UpdateByID updates a single document by its _id field.
// ID can be string or primitive.ObjectID.
func (c *Client) UpdateByID(ctx context.Context, collection string, id any, update any, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        var objID primitive.ObjectID
        var err error

        switch v := id.(type) </span>{
        case string:<span class="cov0" title="0">
                objID, err = primitive.ObjectIDFromHex(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, newOperationError("update by id", err)
                }</span>
        case primitive.ObjectID:<span class="cov0" title="0">
                if v.IsZero() </span><span class="cov0" title="0">{
                        return nil, newOperationError("update by id", errors.New("ObjectID cannot be zero"))
                }</span>
                <span class="cov0" title="0">objID = v</span>
        default:<span class="cov0" title="0">
                return nil, newOperationError("update by id", mongo.ErrInvalidIndexValue)</span>
        }

        <span class="cov0" title="0">filter := bson.M{"_id": objID}
        return c.UpdateOne(ctx, collection, filter, update, opts...)</span>
}

// DeleteByID deletes a single document by its _id field.
// ID can be string or primitive.ObjectID.
func (c *Client) DeleteByID(ctx context.Context, collection string, id any) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        var objID primitive.ObjectID
        var err error

        switch v := id.(type) </span>{
        case string:<span class="cov0" title="0">
                objID, err = primitive.ObjectIDFromHex(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, newOperationError("delete by id", err)
                }</span>
        case primitive.ObjectID:<span class="cov0" title="0">
                if v.IsZero() </span><span class="cov0" title="0">{
                        return nil, newOperationError("delete by id", errors.New("ObjectID cannot be zero"))
                }</span>
                <span class="cov0" title="0">objID = v</span>
        default:<span class="cov0" title="0">
                return nil, newOperationError("delete by id", mongo.ErrInvalidIndexValue)</span>
        }

        <span class="cov0" title="0">filter := bson.M{"_id": objID}
        return c.DeleteOne(ctx, collection, filter)</span>
}

// EstimatedDocumentCount returns an estimated count using collection metadata.
// Faster than CountDocuments but less accurate. Does not support filters.
func (c *Client) EstimatedDocumentCount(ctx context.Context, collection string, opts ...*options.EstimatedDocumentCountOptions) (int64, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        count, err := coll.EstimatedDocumentCount(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, newOperationError("estimated document count", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// UpsertOne updates a document if it exists, or inserts it if it doesn't.
// Returns UpsertedID if inserted, or MatchedCount/ModifiedCount if updated.
func (c *Client) UpsertOne(ctx context.Context, collection string, filter any, update any) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        opts := options.Update().SetUpsert(true)
        return c.UpdateOne(ctx, collection, filter, update, opts)
}</span>

// DropCollection drops an entire collection from the database.
// WARNING: Permanently deletes all documents and indexes.
func (c *Client) DropCollection(ctx context.Context, collection string) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        if err := coll.Drop(ctx); err != nil </span><span class="cov0" title="0">{
                return newOperationError("drop collection", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DropDatabase drops an entire database.
// WARNING: Permanently deletes the database and all its collections.
func (c *Client) DropDatabase(ctx context.Context, database string) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">db := c.GetDatabase(database)
        if err := db.Drop(ctx); err != nil </span><span class="cov0" title="0">{
                return newOperationError("drop database", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WithTransaction executes a function within a transaction with automatic retry.
// All operations in the function must use the provided SessionContext.
func (c *Client) WithTransaction(ctx context.Context, fn func(mongo.SessionContext) error, opts ...*options.TransactionOptions) error <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session, err := c.client.StartSession()
        if err != nil </span><span class="cov0" title="0">{
                return newOperationError("start transaction session", err)
        }</span>
        <span class="cov0" title="0">defer session.EndSession(ctx)

        _, err = session.WithTransaction(ctx, func(sessCtx mongo.SessionContext) (any, error) </span><span class="cov0" title="0">{
                return nil, fn(sessCtx)
        }</span>, opts...)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return newOperationError("transaction", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Watch opens a change stream to watch for real-time changes on a collection.
// Requires MongoDB replica set or sharded cluster (not standalone).
func (c *Client) Watch(ctx context.Context, collection string, pipeline any, opts ...*options.ChangeStreamOptions) (*mongo.ChangeStream, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if err := c.checkState(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">coll := c.GetCollection(collection)
        stream, err := coll.Watch(ctx, pipeline, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newOperationError("watch", err)
        }</span>

        <span class="cov0" title="0">return stream, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package mongo_kit

import (
        "maps"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// Query Builders
//
// This file provides fluent builder interfaces for MongoDB queries, updates, and aggregations.
//
// See docs/query.md for detailed usage guide and examples.

// QueryBuilder provides a fluent interface for building MongoDB queries
type QueryBuilder struct {
        filter     bson.D
        sortFields bson.D
        options    *options.FindOptions
}

// NewQueryBuilder creates a new QueryBuilder instance.
func NewQueryBuilder() *QueryBuilder <span class="cov8" title="1">{
        return &amp;QueryBuilder{
                filter:     bson.D{},
                sortFields: bson.D{},
                options:    options.Find(),
        }
}</span>

// Filter adds a filter condition to the query.
func (qb *QueryBuilder) Filter(key string, value any) *QueryBuilder <span class="cov8" title="1">{
        qb.filter = append(qb.filter, bson.E{Key: key, Value: value})
        return qb
}</span>

// Equals adds an equality filter. Alias for Filter().
func (qb *QueryBuilder) Equals(key string, value any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, value)
}</span>

// NotEquals adds a not equals filter.
func (qb *QueryBuilder) NotEquals(key string, value any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$ne": value})
}</span>

// GreaterThan adds a greater than filter.
func (qb *QueryBuilder) GreaterThan(key string, value any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$gt": value})
}</span>

// GreaterThanOrEqual adds a greater than or equal filter.
func (qb *QueryBuilder) GreaterThanOrEqual(key string, value any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$gte": value})
}</span>

// LessThan adds a less than filter.
func (qb *QueryBuilder) LessThan(key string, value any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$lt": value})
}</span>

// LessThanOrEqual adds a less than or equal filter.
func (qb *QueryBuilder) LessThanOrEqual(key string, value any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$lte": value})
}</span>

// In adds an in filter.
func (qb *QueryBuilder) In(key string, values ...any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$in": values})
}</span>

// NotIn adds a not in filter.
func (qb *QueryBuilder) NotIn(key string, values ...any) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$nin": values})
}</span>

// Exists adds an exists filter.
func (qb *QueryBuilder) Exists(key string, exists bool) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$exists": exists})
}</span>

// Regex adds a regex filter.
func (qb *QueryBuilder) Regex(key string, pattern string, options string) *QueryBuilder <span class="cov8" title="1">{
        return qb.Filter(key, bson.M{"$regex": pattern, "$options": options})
}</span>

// And adds an and condition.
func (qb *QueryBuilder) And(conditions ...bson.D) *QueryBuilder <span class="cov8" title="1">{
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                qb.filter = append(qb.filter, bson.E{Key: "$and", Value: conditions})
        }</span>
        <span class="cov8" title="1">return qb</span>
}

// Or adds an or condition.
func (qb *QueryBuilder) Or(conditions ...bson.D) *QueryBuilder <span class="cov8" title="1">{
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                qb.filter = append(qb.filter, bson.E{Key: "$or", Value: conditions})
        }</span>
        <span class="cov8" title="1">return qb</span>
}

// Nor adds a nor condition.
func (qb *QueryBuilder) Nor(conditions ...bson.D) *QueryBuilder <span class="cov8" title="1">{
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                qb.filter = append(qb.filter, bson.E{Key: "$nor", Value: conditions})
        }</span>
        <span class="cov8" title="1">return qb</span>
}

// Limit sets the maximum number of documents to return.
func (qb *QueryBuilder) Limit(limit int64) *QueryBuilder <span class="cov8" title="1">{
        qb.options.SetLimit(limit)
        return qb
}</span>

// Skip sets the number of documents to skip.
func (qb *QueryBuilder) Skip(skip int64) *QueryBuilder <span class="cov8" title="1">{
        qb.options.SetSkip(skip)
        return qb
}</span>

// Sort adds a field to the sort order.
func (qb *QueryBuilder) Sort(field string, ascending bool) *QueryBuilder <span class="cov8" title="1">{
        order := 1
        if !ascending </span><span class="cov8" title="1">{
                order = -1
        }</span>
        <span class="cov8" title="1">qb.sortFields = append(qb.sortFields, bson.E{Key: field, Value: order})
        qb.options.SetSort(qb.sortFields)
        return qb</span>
}

// SortBy sets custom sort order, replacing any previously set sort fields.
func (qb *QueryBuilder) SortBy(sort any) *QueryBuilder <span class="cov8" title="1">{
        qb.sortFields = bson.D{} // Clear accumulated sort fields
        qb.options.SetSort(sort)
        return qb
}</span>

// Project sets the projection.
func (qb *QueryBuilder) Project(projection any) *QueryBuilder <span class="cov8" title="1">{
        qb.options.SetProjection(projection)
        return qb
}</span>

// GetFilter returns the filter without options.
func (qb *QueryBuilder) GetFilter() bson.D <span class="cov8" title="1">{
        return qb.filter
}</span>

// Build returns the filter and options.
func (qb *QueryBuilder) Build() (bson.D, *options.FindOptions) <span class="cov8" title="1">{
        return qb.filter, qb.options
}</span>

// AndConditions combines multiple QueryBuilders with $and logic.
func (qb *QueryBuilder) AndConditions(builders ...*QueryBuilder) *QueryBuilder <span class="cov8" title="1">{
        if len(builders) == 0 </span><span class="cov8" title="1">{
                return qb
        }</span>

        <span class="cov8" title="1">conditions := make([]bson.D, len(builders))
        for i, builder := range builders </span><span class="cov8" title="1">{
                conditions[i] = builder.GetFilter()
        }</span>

        <span class="cov8" title="1">return qb.And(conditions...)</span>
}

// OrConditions combines multiple QueryBuilders with $or logic.
func (qb *QueryBuilder) OrConditions(builders ...*QueryBuilder) *QueryBuilder <span class="cov8" title="1">{
        if len(builders) == 0 </span><span class="cov8" title="1">{
                return qb
        }</span>

        <span class="cov8" title="1">conditions := make([]bson.D, len(builders))
        for i, builder := range builders </span><span class="cov8" title="1">{
                conditions[i] = builder.GetFilter()
        }</span>

        <span class="cov8" title="1">return qb.Or(conditions...)</span>
}

// NorConditions combines multiple QueryBuilders with $nor logic.
func (qb *QueryBuilder) NorConditions(builders ...*QueryBuilder) *QueryBuilder <span class="cov8" title="1">{
        if len(builders) == 0 </span><span class="cov8" title="1">{
                return qb
        }</span>

        <span class="cov8" title="1">conditions := make([]bson.D, len(builders))
        for i, builder := range builders </span><span class="cov8" title="1">{
                conditions[i] = builder.GetFilter()
        }</span>

        <span class="cov8" title="1">return qb.Nor(conditions...)</span>
}

// Where adds a raw MongoDB expression to the filter.
func (qb *QueryBuilder) Where(expression any) *QueryBuilder <span class="cov8" title="1">{
        switch v := expression.(type) </span>{
        case bson.M:<span class="cov8" title="1">
                for key, value := range v </span><span class="cov8" title="1">{
                        qb.filter = append(qb.filter, bson.E{Key: key, Value: value})
                }</span>
        case bson.D:<span class="cov8" title="1">
                qb.filter = append(qb.filter, v...)</span>
        case bson.E:<span class="cov8" title="1">
                qb.filter = append(qb.filter, v)</span>
        }
        <span class="cov8" title="1">return qb</span>
}

// UpdateBuilder provides a fluent interface for building update operations
type UpdateBuilder struct {
        update bson.D
}

// NewUpdateBuilder creates a new UpdateBuilder instance.
func NewUpdateBuilder() *UpdateBuilder <span class="cov8" title="1">{
        return &amp;UpdateBuilder{
                update: bson.D{},
        }
}</span>

// Set sets field values.
func (ub *UpdateBuilder) Set(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$set", key, value)
        return ub
}</span>

// Unset removes fields.
func (ub *UpdateBuilder) Unset(keys ...string) *UpdateBuilder <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                ub.addOperator("$unset", key, "")
        }</span>
        <span class="cov8" title="1">return ub</span>
}

// Inc increments field values.
func (ub *UpdateBuilder) Inc(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$inc", key, value)
        return ub
}</span>

// Mul multiplies field values.
func (ub *UpdateBuilder) Mul(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$mul", key, value)
        return ub
}</span>

// Min updates field if specified value is less than current value.
func (ub *UpdateBuilder) Min(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$min", key, value)
        return ub
}</span>

// Max updates field if specified value is greater than current value.
func (ub *UpdateBuilder) Max(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$max", key, value)
        return ub
}</span>

// Push appends value to array.
func (ub *UpdateBuilder) Push(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$push", key, value)
        return ub
}</span>

// Pull removes all instances of value from array.
func (ub *UpdateBuilder) Pull(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$pull", key, value)
        return ub
}</span>

// AddToSet adds value to array if not already present.
func (ub *UpdateBuilder) AddToSet(key string, value any) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$addToSet", key, value)
        return ub
}</span>

// Pop removes first or last element from array.
func (ub *UpdateBuilder) Pop(key string, first bool) *UpdateBuilder <span class="cov8" title="1">{
        position := 1
        if first </span><span class="cov8" title="1">{
                position = -1
        }</span>
        <span class="cov8" title="1">ub.addOperator("$pop", key, position)
        return ub</span>
}

// CurrentDate sets field to current date.
func (ub *UpdateBuilder) CurrentDate(key string) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$currentDate", key, true)
        return ub
}</span>

// Rename renames a field.
func (ub *UpdateBuilder) Rename(oldName string, newName string) *UpdateBuilder <span class="cov8" title="1">{
        ub.addOperator("$rename", oldName, newName)
        return ub
}</span>

// addOperator is a helper method to add operators to the update document.
func (ub *UpdateBuilder) addOperator(operator string, key string, value any) <span class="cov8" title="1">{
        // Find existing operator
        for i, elem := range ub.update </span><span class="cov8" title="1">{
                if elem.Key == operator </span><span class="cov8" title="1">{
                        // Operator exists, try to add to it
                        if m, ok := elem.Value.(bson.M); ok </span><span class="cov8" title="1">{
                                // Value is bson.M, add the field
                                m[key] = value
                                ub.update[i].Value = m
                                return
                        }</span>
                        // Value is NOT bson.M (shouldn't happen, but handle it)
                        // Replace with new bson.M containing the field
                        <span class="cov0" title="0">ub.update[i].Value = bson.M{key: value}
                        return</span>
                }
        }

        // Operator doesn't exist, create it
        <span class="cov8" title="1">ub.update = append(ub.update, bson.E{
                Key:   operator,
                Value: bson.M{key: value},
        })</span>
}

// Build returns the update document.
func (ub *UpdateBuilder) Build() bson.D <span class="cov8" title="1">{
        return ub.update
}</span>

// AggregationBuilder provides a fluent interface for building aggregation pipelines.
type AggregationBuilder struct {
        pipeline []bson.D
}

// NewAggregationBuilder creates a new AggregationBuilder instance.
func NewAggregationBuilder() *AggregationBuilder <span class="cov8" title="1">{
        return &amp;AggregationBuilder{
                pipeline: []bson.D{},
        }
}</span>

// Match adds a $match stage.
func (ab *AggregationBuilder) Match(filter any) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, bson.D{{Key: "$match", Value: filter}})
        return ab
}</span>

// Group adds a $group stage.
func (ab *AggregationBuilder) Group(id any, fields bson.M) *AggregationBuilder <span class="cov8" title="1">{
        groupDoc := bson.M{"_id": id}
        maps.Copy(groupDoc, fields)
        ab.pipeline = append(ab.pipeline, bson.D{{Key: "$group", Value: groupDoc}})
        return ab
}</span>

// Sort adds a $sort stage.
func (ab *AggregationBuilder) Sort(sort any) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, bson.D{{Key: "$sort", Value: sort}})
        return ab
}</span>

// Limit adds a $limit stage.
func (ab *AggregationBuilder) Limit(limit int64) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, bson.D{{Key: "$limit", Value: limit}})
        return ab
}</span>

// Skip adds a $skip stage.
func (ab *AggregationBuilder) Skip(skip int64) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, bson.D{{Key: "$skip", Value: skip}})
        return ab
}</span>

// Project adds a $project stage.
func (ab *AggregationBuilder) Project(projection any) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, bson.D{{Key: "$project", Value: projection}})
        return ab
}</span>

// Unwind adds an $unwind stage.
func (ab *AggregationBuilder) Unwind(path string) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, bson.D{{Key: "$unwind", Value: path}})
        return ab
}</span>

// Lookup adds a $lookup stage for joins.
func (ab *AggregationBuilder) Lookup(from, localField, foreignField, as string) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, bson.D{{
                Key: "$lookup",
                Value: bson.M{
                        "from":         from,
                        "localField":   localField,
                        "foreignField": foreignField,
                        "as":           as,
                },
        }})
        return ab
}</span>

// AddStage adds a custom pipeline stage.
func (ab *AggregationBuilder) AddStage(stage bson.D) *AggregationBuilder <span class="cov8" title="1">{
        ab.pipeline = append(ab.pipeline, stage)
        return ab
}</span>

// Build returns the aggregation pipeline.
func (ab *AggregationBuilder) Build() []bson.D <span class="cov8" title="1">{
        return ab.pipeline
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package mongo_kit

import (
        "context"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// Repository Pattern
//
// This file provides a type-safe, generic repository pattern for MongoDB operations.
//
// See docs/repository.md for detailed usage guide and examples.

// Repository provides a type-safe, collection-specific interface for database operations.
type Repository[T any] struct {
        client     *Client
        collection string
}

// NewRepository creates a new type-safe repository for the specified collection.
func NewRepository[T any](client *Client, collection string) *Repository[T] <span class="cov0" title="0">{
        return &amp;Repository[T]{
                client:     client,
                collection: collection,
        }
}</span>

// Create inserts a new document and returns its ID.
func (r *Repository[T]) Create(ctx context.Context, document T) (any, error) <span class="cov0" title="0">{
        result, err := r.client.InsertOne(ctx, r.collection, document)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result.InsertedID, nil</span>
}

// CreateMany inserts multiple documents and returns their IDs.
func (r *Repository[T]) CreateMany(ctx context.Context, documents []T) ([]any, error) <span class="cov0" title="0">{
        // Convert []T to []any for InsertMany
        docs := make([]any, len(documents))
        for i, doc := range documents </span><span class="cov0" title="0">{
                docs[i] = doc
        }</span>

        <span class="cov0" title="0">result, err := r.client.InsertMany(ctx, r.collection, docs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result.InsertedIDs, nil</span>
}

// FindByID finds a single document by its _id field.
// Returns mongo.ErrNoDocuments if not found.
func (r *Repository[T]) FindByID(ctx context.Context, id any) (*T, error) <span class="cov0" title="0">{
        var result T
        err := r.client.FindByID(ctx, r.collection, id, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;result, nil</span>
}

// FindOne finds a single document matching the filter.
// Returns mongo.ErrNoDocuments if not found.
func (r *Repository[T]) FindOne(ctx context.Context, filter any, opts ...*options.FindOneOptions) (*T, error) <span class="cov0" title="0">{
        var result T
        err := r.client.FindOne(ctx, r.collection, filter, &amp;result, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;result, nil</span>
}

// Find finds all documents matching the filter.
func (r *Repository[T]) Find(ctx context.Context, filter any, opts ...*options.FindOptions) ([]T, error) <span class="cov0" title="0">{
        var results []T
        err := r.client.Find(ctx, r.collection, filter, &amp;results, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

// FindAll returns all documents in the collection.
func (r *Repository[T]) FindAll(ctx context.Context, opts ...*options.FindOptions) ([]T, error) <span class="cov0" title="0">{
        return r.Find(ctx, bson.M{}, opts...)
}</span>

// UpdateByID updates a single document by its _id field.
func (r *Repository[T]) UpdateByID(ctx context.Context, id any, update any, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        return r.client.UpdateByID(ctx, r.collection, id, update, opts...)
}</span>

// UpdateOne updates a single document matching the filter.
func (r *Repository[T]) UpdateOne(ctx context.Context, filter any, update any, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        return r.client.UpdateOne(ctx, r.collection, filter, update, opts...)
}</span>

// UpdateMany updates all documents matching the filter.
func (r *Repository[T]) UpdateMany(ctx context.Context, filter any, update any, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        return r.client.UpdateMany(ctx, r.collection, filter, update, opts...)
}</span>

// Upsert updates a document if it exists, or inserts it if it doesn't.
func (r *Repository[T]) Upsert(ctx context.Context, filter any, update any) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        return r.client.UpsertOne(ctx, r.collection, filter, update)
}</span>

// DeleteByID deletes a single document by its _id field.
func (r *Repository[T]) DeleteByID(ctx context.Context, id any) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        return r.client.DeleteByID(ctx, r.collection, id)
}</span>

// DeleteOne deletes a single document matching the filter.
func (r *Repository[T]) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        return r.client.DeleteOne(ctx, r.collection, filter)
}</span>

// DeleteMany deletes all documents matching the filter.
func (r *Repository[T]) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        return r.client.DeleteMany(ctx, r.collection, filter)
}</span>

// Count returns the number of documents matching the filter.
func (r *Repository[T]) Count(ctx context.Context, filter any, opts ...*options.CountOptions) (int64, error) <span class="cov0" title="0">{
        return r.client.CountDocuments(ctx, r.collection, filter, opts...)
}</span>

// CountAll counts all documents in the collection.
func (r *Repository[T]) CountAll(ctx context.Context, opts ...*options.CountOptions) (int64, error) <span class="cov0" title="0">{
        return r.Count(ctx, bson.M{}, opts...)
}</span>

// EstimatedCount returns an estimated count using collection metadata.
// Faster than Count but may be less accurate.
func (r *Repository[T]) EstimatedCount(ctx context.Context, opts ...*options.EstimatedDocumentCountOptions) (int64, error) <span class="cov0" title="0">{
        return r.client.EstimatedDocumentCount(ctx, r.collection, opts...)
}</span>

// Exists checks if at least one document matching the filter exists.
func (r *Repository[T]) Exists(ctx context.Context, filter any) (bool, error) <span class="cov0" title="0">{
        count, err := r.client.CountDocuments(ctx, r.collection, filter, options.Count().SetLimit(1))
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// ExistsByID checks if a document with the given _id exists.
func (r *Repository[T]) ExistsByID(ctx context.Context, id any) (bool, error) <span class="cov0" title="0">{
        _, err := r.FindByID(ctx, id)
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// Aggregate executes an aggregation pipeline and returns typed results.
func (r *Repository[T]) Aggregate(ctx context.Context, pipeline any, opts ...*options.AggregateOptions) ([]T, error) <span class="cov0" title="0">{
        var results []T
        err := r.client.Aggregate(ctx, r.collection, pipeline, &amp;results, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

// Drop deletes the entire collection.
// WARNING: This permanently deletes all documents and indexes.
func (r *Repository[T]) Drop(ctx context.Context) error <span class="cov0" title="0">{
        return r.client.DropCollection(ctx, r.collection)
}</span>

// FindWithBuilder finds documents using a QueryBuilder for complex queries.
func (r *Repository[T]) FindWithBuilder(ctx context.Context, qb *QueryBuilder) ([]T, error) <span class="cov0" title="0">{
        filter, opts := qb.Build()
        return r.Find(ctx, filter, opts)
}</span>

// FindOneWithBuilder finds a single document using a QueryBuilder.
// Returns mongo.ErrNoDocuments if not found.
func (r *Repository[T]) FindOneWithBuilder(ctx context.Context, qb *QueryBuilder) (*T, error) <span class="cov0" title="0">{
        filter, opts := qb.Build()

        // Extract FindOneOptions from FindOptions
        findOneOpts := options.FindOne()
        if opts.Sort != nil </span><span class="cov0" title="0">{
                findOneOpts.SetSort(opts.Sort)
        }</span>
        <span class="cov0" title="0">if opts.Projection != nil </span><span class="cov0" title="0">{
                findOneOpts.SetProjection(opts.Projection)
        }</span>
        <span class="cov0" title="0">if opts.Skip != nil </span><span class="cov0" title="0">{
                findOneOpts.SetSkip(*opts.Skip)
        }</span>

        <span class="cov0" title="0">return r.FindOne(ctx, filter, findOneOpts)</span>
}

// CountWithBuilder counts documents using a QueryBuilder filter.
func (r *Repository[T]) CountWithBuilder(ctx context.Context, qb *QueryBuilder) (int64, error) <span class="cov0" title="0">{
        filter := qb.GetFilter()
        return r.Count(ctx, filter)
}</span>

// ExistsWithBuilder checks if at least one document matching the QueryBuilder exists.
func (r *Repository[T]) ExistsWithBuilder(ctx context.Context, qb *QueryBuilder) (bool, error) <span class="cov0" title="0">{
        filter := qb.GetFilter()
        return r.Exists(ctx, filter)
}</span>

// Collection returns the name of the collection this repository operates on.
func (r *Repository[T]) Collection() string <span class="cov0" title="0">{
        return r.collection
}</span>

// Client returns the underlying MongoDB client for operations outside the repository pattern.
func (r *Repository[T]) Client() *Client <span class="cov0" title="0">{
        return r.client
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
