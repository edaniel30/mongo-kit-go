name: Automatic Release on Merge

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  create_release:
    # Only runs if:
    # 1. The PR was merged (not just closed)
    # 2. Comes from release/* or hotfix/*
    # 3. The target is main
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main' &&
      (startsWith(github.head_ref, 'release/') || startsWith(github.head_ref, 'hotfix/'))

    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main  # Ensure we're on main
          token: ${{ secrets.TOKEN_FOR_RELEASES }}  # Use custom token for git operations

      - name: Get latest version and determine new version
        id: get_version_info
        run: |
          set -e  # Fail if any command fails

          # Get latest version or use v0.0.0 as base for first release
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            LAST_VERSION=$(git describe --tags --abbrev=0)
            echo "üìå Last version: $LAST_VERSION"
          else
            LAST_VERSION="v0.0.0"
            echo "‚ö†Ô∏è  No tags found. Using $LAST_VERSION as base for first release."
          fi

          # Extract version numbers (e.g., '0.0.0')
          VERSION_NUMBERS=$(echo "$LAST_VERSION" | sed 's/^v//')

          # Split into Major, Minor, Patch
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUMBERS"

          # Get source branch name
          BRANCH_NAME="${{ github.head_ref }}"
          echo "üåø Source branch: $BRANCH_NAME"

          # Calculate new version based on branch type
          if [[ "$BRANCH_NAME" == release/* ]]; then
            # Release: increment minor, reset patch
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
            NEW_VERSION="${MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
            RELEASE_TYPE="Release"

            # Extract clean branch name
            RELEASE_NAME=$(echo "${BRANCH_NAME}" | sed -E 's/^release\///' | tr '-' ' ')

          elif [[ "$BRANCH_NAME" == hotfix/* ]]; then
            # Hotfix: only increment patch
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            RELEASE_TYPE="Hotfix"

            # Extract clean branch name
            RELEASE_NAME=$(echo "${BRANCH_NAME}" | sed -E 's/^hotfix\///' | tr '-' ' ')
          fi

          echo "‚úÖ New version: v${NEW_VERSION}"
          echo "üìù Type: $RELEASE_TYPE"
          echo "üè∑Ô∏è  Name: $RELEASE_NAME"

          # Save outputs
          echo "tag_name=v${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "release_name=v${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN_FOR_RELEASES }}
        with:
          tag_name: ${{ steps.get_version_info.outputs.tag_name }}
          name: ${{ steps.get_version_info.outputs.release_name }}
          draft: false
          prerelease: false
          generate_release_notes: true  # Auto-generate release notes with PR links

      - name: Delete merged branch
        if: success()
        run: |
          BRANCH_NAME="${{ steps.get_version_info.outputs.branch_name }}"

          echo "üóëÔ∏è  Deleting remote branch ${BRANCH_NAME}..."
          git push origin --delete ${BRANCH_NAME} || echo "Branch already deleted or doesn't exist remotely"

          echo "‚úÖ Cleanup complete"

      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Release creation failed!"
          echo "Please check the logs and create the release manually."
          exit 1
